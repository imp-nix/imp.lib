/**
  Entry point for imp - directory-based Nix imports.

  This module exports the main imp API including:
  - Chainable filtering and transformation methods
  - Tree building from directory structure
  - Registry for named module discovery
  - Utilities for flake input collection
*/
let
  utils = import ./lib.nix;
  perform = import ./collect.nix;
  inherit (utils) inModuleEval;

  /**
    Scan directories for `__inputs` declarations and collect them.

    Recursively scans .nix files for `__inputs` attribute declarations
    and merges them into a single attrset. Detects conflicts when the
    same input name has different definitions in different files.

    Only attrsets with `__inputs` are collected. For files that need to
    be functions (e.g., to receive `inputs` at runtime), use the `__functor`
    pattern so `__inputs` is accessible without calling the function:

    ```nix
    {
      __inputs.foo.url = "github:foo/bar";
      __functor = _: { inputs, ... }: inputs.foo.lib.something;
    }
    ```

    Accepts either a single path or a list of paths. When given multiple
    paths, all are scanned and merged with conflict detection.

    # Example

    ```nix
    # Single path
    imp.collectInputs ./outputs
    # => { treefmt-nix = { url = "github:numtide/treefmt-nix"; }; }

    # Multiple paths
    imp.collectInputs [ ./outputs ./registry ]
    # => { treefmt-nix = { ... }; nur = { ... }; }
    ```

    # Arguments

    pathOrPaths
    : Directory/file path, or list of paths, to scan for __inputs declarations.
  */
  collectInputs = import ./collect-inputs.nix;

  flakeFormat = import ./format-flake.nix;
  inherit (flakeFormat) formatInputs formatFlake;

  # Registry utilities (requires lib)
  registryModule = import ./registry.nix;

  /**
    Convenience function combining collectInputs and formatFlake.

    Scans a directory for `__inputs` declarations and generates
    complete flake.nix content in one step.

    # Example

    ```nix
    imp.collectAndFormatFlake {
      src = ./outputs;
      coreInputs = { nixpkgs.url = "github:nixos/nixpkgs"; };
      description = "My flake";
    }
    # => "{ description = \"My flake\"; inputs = { ... }; ... }"
    ```

    # Arguments

    src
    : Directory to scan for __inputs declarations.

    coreInputs
    : Core flake inputs attrset (optional).

    description
    : Flake description string (optional).

    outputsFile
    : Path to outputs file (default: "./outputs.nix").

    header
    : Header comment for generated file (optional).
  */
  collectAndFormatFlake =
    {
      src,
      coreInputs ? { },
      description ? "",
      outputsFile ? "./outputs.nix",
      header ? "# Auto-generated by imp - DO NOT EDIT\n# Regenerate with: nix run .#imp-flake",
    }:
    let
      collectedInputs = collectInputs src;
    in
    formatFlake {
      inherit
        description
        coreInputs
        collectedInputs
        outputsFile
        header
        ;
    };

  # Makes imp callable: imp ./path or imp { config, ... }
  functor = self: arg: perform self.__config (if inModuleEval arg then [ ] else arg);

  # The imp builder object - a stateful configuration that produces the API
  callable =
    let
      # Initial configuration state
      initial = {
        api = { };
        mapf = (i: i);
        treef = import;
        filterf = _: true;
        paths = [ ];

        # State functor: receives update function, returns new state with bound API
        __functor =
          config: update:
          let
            updated = update config;
            current = config update;
            boundAPI = builtins.mapAttrs (_: g: g current) updated.api;

            # Import API methods with current state
            apiMethods = import ./api.nix {
              inherit
                config
                update
                updated
                current
                callable
                ;
            };
          in
          boundAPI
          // apiMethods
          // {
            __config = updated;
            __functor = functor;

            # Standalone utilities available on imp object
            inherit
              collectInputs
              formatInputs
              formatFlake
              collectAndFormatFlake
              registryModule
              ;

            # Convenience: build registry with current lib
            # Usage: (imp.withLib lib).registry ./nix
            registry =
              path:
              if updated.lib == null then
                throw "You need to call withLib before using registry."
              else
                (registryModule { lib = updated.lib; }).buildRegistry path;
          };
      };
    in
    initial (config: config);

in
callable
